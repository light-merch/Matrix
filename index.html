<!DOCTYPE HTML>
<html>
    <head>
        <title>Matrix</title>


        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100%; };
        </style>
    </head>

    <body>
        <script src="build/three.js"></script>
        <script src="build/stats.min.js"></script>
        <script src="build/OrbitControls.js"></script>
        <script src="build/dat.gui.min.js"></script>

        <script type="module">
            import { GLTFLoader } from './build/GLTFLoader.js';
            import { RGBELoader } from './build/RGBELoader.js';
            import { RoughnessMipmapper } from './build/RoughnessMipmapper.js';
        </script>

        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader<br />
            Battle Damaged Sci-fi Helmet by
            <a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a><br />
            <a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> by <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
        </div>

        <script type="text/javascript">
            var loadTextures = function(path, is_matrix) {
                if (is_matrix) {
                    var material = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true});
                    console.log("kek");
                } else {
                    console.log("lol");
                    var material = [
                        new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // RIGHT SIDE
                        new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // LEFT SIDE
                        new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // TOP SIDE
                        new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // BOTTOM SIDE
                        new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide}), // FRONT SIDE
                        new THREE.MeshLambertMaterial({map: new THREE.TextureLoader().load(path), side: THREE.DoubleSide})  // BACK SIDE
                    ];
                }
                return material;
            };


            var FizzyText = function() {
                this.message = 'dat.gui';
                this.speed = 0.8;
                this.matrix_style = false;
                this.explode = function() {};
            };


            window.onload = function() {
                var text = new FizzyText();
                var gui = new dat.GUI();
                gui.add(text, 'message');
                control = gui.add(text, 'speed', -5, 5);
                matrix = gui.add(text, 'matrix_style');
                gui.add(text, 'explode');

                control.onChange(function(value){
                    cube.position.y += value;
                });

                matrix.onChange(function(value){
                    if (value) {
                        IS_MATRIX = true;
                        console.log("true")
                    } else {
                        IS_MATRIX = false;
                        console.log("false")
                    }
                });
            };
        </script>

        <script>
            var IS_MATRIX = true;

            var stats = initStats();
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', function() {
                var width = window.innerWidth;
                var height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            });

            document.addEventListener('keydown', onDocumentKeyDown, false);
            function onDocumentKeyDown(event) {
                var keyCode = event.which;
                if (keyCode == 87) {
                    cube.position.y += 1;
                } else if (keyCode == 83) {
                    cube.position.y -= 1;
                } else if (keyCode == 65) {
                    cube.position.x -= 1;
                } else if (keyCode == 68) {
                    cube.position.x += 1;
                } else if (keyCode == 32) {
                    cube.position.set(0, 0, 0);
                }
            };


            // instantiate a loader
            /*var loader = new THREE.GLTFLoader();

            // optional: Provide a DRACOLoader instance to decode compressed mesh data
            var dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath( '/examples/js/libs/draco/' );
            loader.setDRACOLoader( dracoLoader );

            // load a glTF resource
            loader.load(
                // resource URL
                'models/gltf/duck/duck.gltf',
                // called when the resource is loaded
                function ( gltf ) {

                    scene.add( gltf.scene );

                    gltf.animations; // Array<THREE.AnimationClip>
                    gltf.scene; // THREE.Scene
                    gltf.scenes; // Array<THREE.Scene>
                    gltf.cameras; // Array<THREE.Camera>
                    gltf.asset; // Object

                },
                // called while loading is progressing
                function ( xhr ) {

                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {

                    console.log( 'An error happened' );

                }
            );*/

            var wood = 'textures/wood.jpg';
            var wood2 = 'textures/wood2.jpg';
            var concrete = 'textures/concrete.jpg';

            controls = new THREE.OrbitControls(camera, renderer.domElement);

            // create the shape
            var geometry = new THREE.BoxGeometry(1, 1, 1);
            var cubeMaterials = loadTextures(concrete, IS_MATRIX);

            // create a material, color or image texture
            var material = new THREE.MeshFaceMaterial(cubeMaterials);
            var cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            camera.position.z = 3;


            // floor
            var geometry = new THREE.BoxGeometry(0.5, 10, 10);
            var floorMaterials = loadTextures(road, IS_MATRIX);
            var floor = new THREE.Mesh(geometry, floorMaterials);
            floor.position.x = 0;
            floor.position.y = -1;
            floor.position.z = 0;
            floor.rotation.z = 1.57;
            scene.add(floor);


            // light
            var ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.8);
            scene.add(ambientLight);

            var light1 = new THREE.PointLight(0xFFFFFF, 0.5, 500);
            light1.position.x = 3;
            light1.position.y = 2;
            light1.position.z = 2;
            scene.add(light1);

            // light position
            var geometry = new THREE.SphereGeometry(0.1, 5, 5);
            var material = new THREE.MeshBasicMaterial({color: 0x0000FF, wireframe: true});
            var point = new THREE.Mesh(geometry, material);
            point.position.x = 3;
            point.position.y = 2;
            point.position.z = 2;
            scene.add(point);


            // game logic
            var update = function() {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.005;
            };

            // draw scene
            var render = function() {
                renderer.render(scene, camera);
            };

            // run game loop (update, render, repeat)
            var frameId = 0;
            var GameLoop = function() {
                requestAnimationFrame(GameLoop);
                stats.begin();
                frameId ++;

                update();
                render();
                stats.end();
            };

            GameLoop();

            function initStats() {
                var stats = new Stats();
                stats.setMode(0); // 0: fps, 1: ms

                // Align top-left
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';

                document.body.appendChild(stats.dom);
                return stats;
            }
        </script>
    </body>
</html>